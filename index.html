<!DOCTYPE html>
<html lang=en>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script  src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script>
<style>
  @keyframes slideUpFade{
from{
transform: translateY(20px);
opacity: 0;
}
to{
transform: translateY(0);
opacity: 1;
}
  }
body {
background-color: #ff9999;
display: flex;
align-items: center;
flex-direction: column;
}
#camera {
border: none;
border-radius: 10px;
box-shadow: 0 0 10px rgba(0,0,0,0.5);
display: block;
width: 300px;
height: 400px;
object-fit: cover;
padding: 5px;
  animation: slideUpFade 0.5s ease-out;
}
#picdiv{
border: 2px solid white;
border-radius: 10px;
box-shadow: 0 0 10px rgba(0,0,0,0.5);
display: block;
width: 300px;
height: 400px;
object-fit: cover;

  animation: slideUpFade 0.5s ease-out;
}
#picdiv > canvas,#previewcanvas {
padding: 5px;
border: none;
border-radius: 10px;
}
#btn,#btn1,#btn2,#btn3,#btn4{
background-color: FloralWhite;
  border-radius: 10px;
  border: none;
  padding: 10px;
  animation: slideUpFade 0.5s ease-out;
}
#btn:hover,#btn1:hover,#btn2:hover,#btn3:hover,#btn4:hover{
background-color: red;
transform: scale(1.03);
transition: all 0.2s ease-in-out;
}
#overlay,#newoverlay{
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  visibility: hidden;
     display: flex;
     flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 1001;
    backdrop-filter: blur(8px);
    background-color: rgba(0,0,0,0.5);
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  #newoverlay div {
    background-color: white;
    padding: 20px 30px;
    border-radius: 10px;
    font-size: 1.5em;
    text-align: center;
    color: black;
    box-shadow: 0 0 15px rgba(0,0,0,0.5);
}
  #overlay.show,#newoverlay.show{
    visibility: visible;
    opacity: 1;
  }
  #previewcanvas{
    max-height: 90vh;
    max-width: 90vw;
    height: auto;
    width: auto;
    z-index: 1002;
    border-radius: 10px;
    border: none;
  }
</style>
    <title>Camera Access</title>
</head>
<body>
  <div id="main" style="display:none;">
  <div id="newoverlay">
  <div id="message">
  <p id="p">Capturing image...</p>
  </div>
  <button id="btn4" style="z-index: 1002;">cancel</button>
  </div>
    <div id="overlay">
      <canvas id="previewcanvas"></canvas>
      <button id="btn3" style="z-index: 1002;">close</button>
    </div>
    <h2>Enter a picture of your face </h2>
    <div style="position:relative; width:300px; height:400px;">
    <video id="camera" width="300" height="400" autoplay></video>
    <canvas id="overlaycanvas" style="position:absolute;top:0;left:0;width:300px;height:400px;"></canvas>
    </div>
    <div style="padding: 10px;">
    <button id="btn" style="display:none;">Capture manually</button>
    <button id="btn1" style="display:none;">Clear</button>
    </div>
    <div id="picdiv" style="display:none;">
    <canvas id="snapshot" width="300" height="400" title="preview image"></canvas>
      <button id="btn2" style="display:none;">download image</button>
    </div>
  </div>
    <script>
        const video = document.getElementById('camera');
        const canvas = document.getElementById('snapshot');
        const previewcanvas = document.getElementById('previewcanvas');
        const context = canvas.getContext('2d');
        const copiedContext = previewcanvas.getContext('2d');
        const main = document.getElementById('main');
        const savebtn = document.getElementById('btn2');
      const clearbtn =  document.getElementById('btn1');
      const capturebtn = document.getElementById('btn');
      const overlay = document.getElementById("overlay");
      const closebtn = document.getElementById('btn3');
      const overlaycanvas = document.getElementById('overlaycanvas');
      const overlayContext = overlaycanvas.getContext('2d');
      const newoverlay = document.getElementById('newoverlay');
      const cancelbtn = document.getElementById('btn4');
      const picdiv = document.getElementById('picdiv');
      let canceled = false;
      let imgname = null;
      const savebtn_clone = savebtn.cloneNode(true);
      const newoverlay_clone = newoverlay.cloneNode(true);
      const message_clone = document.getElementById("message").cloneNode(true);
      newoverlay_clone.innerHTML = '';
      message_clone.innerHTML = '';
      const p = document.createElement("p");
      p.textContent = "enter image name...";
      message_clone.style.display = "flex";
      message_clone.style.flexDirection = "column";
      message_clone.style.alignItems = "center";
      message_clone.style.justifyContent = "center";
      const input = document.createElement("input");
      input.type = "text";
      input.placeHolder = "enter the name of the photo";
      const downloadbtn = document.createElement("button");
      downloadbtn.innerText = 'save';
      downloadbtn.addEventListener("click", () => {
    if (input.value === '') return;
    imgname = input.value;

    const dataURL = canvas.toDataURL('image/png');

    const img = new Image();
    img.onload = function() {
        ImageTracer.imageToSVG(img, function(svgString) {
            const blob = new Blob([svgString], { type: "image/svg+xml" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = imgname + '.svg';
            link.click();

            newoverlay_clone.classList.remove("show");
        }, 'posterized2');  // You can adjust preset
    };
    img.src = dataURL;
});
      message_clone.appendChild(p);
      message_clone.appendChild(input);
      message_clone.appendChild(downloadbtn);
      newoverlay_clone.appendChild(message_clone);
      document.body.appendChild(newoverlay_clone);
      //load face detection model
      let model;
      let interval1 = null;
      async function loadModel(){
          model = await blazeface.load();
          console.log("face detection model loaded");
      }
      let detectionPaused = false;
      let stopwork = false;
function showCapturedFace(start, area) {
    if (detectionPaused || canceled) return;  // Skip capturing forever if canceled

    // Pause face detection for the capturing animation
    detectionPaused = true;
    newoverlay.classList.add('show');
    void newoverlay.offsetWidth;

    setTimeout(() => {
    if(canceled) return;
        newoverlay.classList.remove('show');
        savebtn_clone.style.display = 'inline-block';
        overlay.appendChild(savebtn_clone);
        overlay.classList.add('show');

        copiedContext.clearRect(0, 0, previewcanvas.width, previewcanvas.height);
        copiedContext.drawImage(
            video,
            start[0], start[1], area[0], area[1],
            0, 0, previewcanvas.width, previewcanvas.height
        );
    }, 3000);
}

let interval = null;
      // Request camera access
        navigator.mediaDevices.getUserMedia({ video: true })
            .then(stream => {
                loadModel();
                video.srcObject = stream;
                main.style.display = "block";
                video.addEventListener("loadeddata", () => {
                overlaycanvas.width = video.videoWidth;
                overlaycanvas.height = video.videoHeight;
             interval =  setInterval(async () =>{
                overlayContext.clearRect(0, 0, overlaycanvas.width, overlaycanvas.height);
                const liveTensors = false;
                const livePredictions = await model.estimateFaces(video,liveTensors);
                if(livePredictions.length > 0){
                livePredictions.forEach(pred => {
                const start = pred.topLeft;
                const end = pred.bottomRight;
                const area = [end[0] - start[0], end[1] - start[1]];
                overlayContext.strokeStyle = "red";
                overlayContext.lineWidth = 3;
                overlayContext.strokeRect(start[0], start[1], area[0], area[1]);
                if(!canceled&&!detectionPaused){
                showCapturedFace(start,area);
                }
                });
                }
                },100);
                });
            })
            .catch(err => {
                console.error('Error accessing camera:', err);
                alert('Please allow camera access!');

            });

        capturebtn.addEventListener("click",async () => {
            context.drawImage(video, 0, 0, canvas.width, canvas.height);
          const tensors = false;
          const prediction = await model.estimateFaces(canvas,tensors);
          if(prediction.length > 0){
            alert("a face was detected");
          }
          else{
            alert("no face detected");
          }
            savebtn.style.display = "inline-block";
        });
        clearbtn.addEventListener("click",() => {
           context.clearRect( 0, 0, canvas.width, canvas.height);
          savebtn.style.display = "none";
        });
        savebtn.addEventListener("click",() => {
        newoverlay_clone.classList.add("show");
        });
         savebtn_clone.addEventListener("click",() => {
         newoverlay_clone.classList.add("show");
        });
      canvas.addEventListener("click", () => {
          overlay.classList.add('show');
          copiedContext.drawImage(canvas,0,0,previewcanvas.width, previewcanvas.height);
      });
      closebtn.addEventListener("click", () => {
         overlay.classList.remove('show');
         savebtn_clone.style.display = 'none';
         detectionPaused = false;
      });
      cancelbtn.addEventListener("click", () => {
      newoverlay.classList.remove('show');
      canceled = true;
        capturebtn.style.display = "inline-block";
        clearbtn.style.display = "inline-block";
        picdiv.style.display = "inline-block";
      clearInterval(interval1);
      });
    </script>
</body>
</html>
